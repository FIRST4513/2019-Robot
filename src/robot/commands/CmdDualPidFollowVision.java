// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package robot.commands;
import robot.utils.BearingPid;
import robot.utils.DistancePid;
import edu.wpi.first.wpilibj.command.Command;
import robot.Robot;

public class CmdDualPidFollowVision extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
	
    // for computing deltaT for the controller
    // (this could also be done in the controller update method)
    private double mPreviousTime = -1;
    
    // the controllers
    DistancePid mDistController ;
    BearingPid  mBearingController ;
    
    double mStartOrientationDegCCW ;
    double mFinalOrientationDegCCW ;	

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public CmdDualPidFollowVision(double standoffXft, double standoffYft,
            double initialOrientDegCCW, double finalOrientDegCCW) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drivetrain);
        requires(Robot.visionSubSys);
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    	
        mDistController = new DistancePid(standoffXft, standoffYft);
        mBearingController = new BearingPid(standoffXft, standoffYft) ;
        
        mStartOrientationDegCCW = initialOrientDegCCW ;
        mFinalOrientationDegCCW = finalOrientDegCCW ;
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
        // initialize for computing deltaT
        mPreviousTime = System.currentTimeMillis(); 
        // the controllers don't use position data
        // but they do need Yaw Data, which can come from
        // either the IMU or the Position Tracker. We
        // initialize both so we can change our minds
        // in the drivetrain code later on, depending
        // upon the relative performance of the two approaches.
        Robot.drivetrain.resetGyro();
    	Robot.drivetrain.resetEncodersAndStats();    
       	Robot.drivetrain.resetPosition(true);
    	Robot.drivetrain.setInitialOrientationDegCCW(mStartOrientationDegCCW);    
        double dist = Robot.visionSubSys.getDistFt() ;
        double bearing = Robot.visionSubSys.getBearingDegCW() ;
        double orient = Robot.drivetrain.getOrientDegCCW() ;    	
        mDistController.start(dist,bearing);
        mBearingController.start(dist,bearing,orient);
        
        Robot.logger.appendLog("CmdDualPidFollowVision Init");
    	Robot.drivetrain.setLoggingOn();
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
        // get deltaT in seconds for the controller
        double now = System.currentTimeMillis();
        double elapsed = (now - mPreviousTime) / 1000.0 ;        
        mPreviousTime = now;   
        
        // get inputs to the two PIDs
        double dist = Robot.visionSubSys.getDistFt() ;
        double bearing = Robot.visionSubSys.getBearingDegCW() ;
        double orient = Robot.drivetrain.getOrientDegCCW() ;                      
        
        // update and get control output from the two PIDs
        double distControl = mDistController.update(dist, bearing, elapsed) ;
        double bearingControl = mBearingController.update(dist, bearing, orient, elapsed);
        // combine them
        double left = (distControl+bearingControl) ;  // / 2.0 ;
        double right = (distControl-bearingControl) ; // / 2.0 ;
        
        // command the drivetrain
        Robot.drivetrain.tankDrive(left, right);
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
    	// we're done when distance pid is done
        boolean distFin = mDistController.isFinished() ;
        if (distFin) {
            Robot.drivetrain.tankDrive(0, 0);
            mDistController.stop();
            mBearingController.stop();
        }
        return distFin ;    
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        mDistController.stop();
        mBearingController.stop();
        Robot.drivetrain.tankDrive(0, 0);

        Robot.logger.appendLog("CmdDualPidFollowVision End");
    	Robot.drivetrain.setLoggingOff();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	end();
    }
    
    @Override 
    public String toString() {
        return "CmdDualPidFollowVision" ;
    }
}
